/*
 * Copyright (c) 2023 - 2025 Rachit
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * GLSL Port of https://github.com/GameTechDev/XeGTAO/
 * Copyright (C) 2016-2021, Intel Corporation
 * SPDX-License-Identifier: MIT
 */

#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_buffer_reference2    : enable
#extension GL_EXT_scalar_block_layout  : enable

#include "Constants/AO/XeGTAO/DepthPreFilter.glsl"
#include "Math.glsl"
#include "Constants.glsl"
#include "MegaSet.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

shared float g_ScratchDepths[8][8];

float XeGTAO_DepthMipFilter(float depth0, float depth1, float depth2, float depth3);

void main()
{
    uvec2 lID = gl_LocalInvocationID.xy;

    vec2 depthTexelSize = 1.0f / vec2(textureSize(sampler2D(Textures[Constants.SceneDepthIndex], Samplers[Constants.DepthSamplerIndex]), 0));

    // MIP 0
    ivec2 baseCoord   = ivec2(gl_GlobalInvocationID.xy);
    ivec2 pixelCoord  = 2 * baseCoord;
    vec2  pixelCenter = vec2(pixelCoord) + vec2(0.5f);

    vec4 depths4 = textureGatherOffset(sampler2D(Textures[Constants.SceneDepthIndex], Samplers[Constants.DepthSamplerIndex]), pixelCenter * depthTexelSize, ivec2(1, 1));

    float depth0 = depths4.w;
    float depth1 = depths4.z;
    float depth2 = depths4.x;
    float depth3 = depths4.y;

    imageStore(Images[Constants.OutDepthMip0Index], pixelCoord + ivec2(0, 0), vec4(depth0, 0.0f, 0.0f, 0.0f));
    imageStore(Images[Constants.OutDepthMip0Index], pixelCoord + ivec2(1, 0), vec4(depth1, 0.0f, 0.0f, 0.0f));
    imageStore(Images[Constants.OutDepthMip0Index], pixelCoord + ivec2(0, 1), vec4(depth2, 0.0f, 0.0f, 0.0f));
    imageStore(Images[Constants.OutDepthMip0Index], pixelCoord + ivec2(1, 1), vec4(depth3, 0.0f, 0.0f, 0.0f));

    // MIP 1
    float dm1 = XeGTAO_DepthMipFilter(depth0, depth1, depth2, depth3);
    imageStore(Images[Constants.OutDepthMip1Index], baseCoord, vec4(dm1, 0.0f, 0.0f, 0.0f));
    g_ScratchDepths[lID.x][lID.y] = dm1;

    memoryBarrierShared();
    barrier();

    // MIP 2
    if (all(equal(lID % uvec2(2), uvec2(0))))
    {
        float inTL = g_ScratchDepths[lID.x + 0][lID.y + 0];
        float inTR = g_ScratchDepths[lID.x + 1][lID.y + 0];
        float inBL = g_ScratchDepths[lID.x + 0][lID.y + 1];
        float inBR = g_ScratchDepths[lID.x + 1][lID.y + 1];

        float dm2 = XeGTAO_DepthMipFilter(inTL, inTR, inBL, inBR);
        imageStore(Images[Constants.OutDepthMip2Index], baseCoord / 2, vec4(dm2, 0.0f, 0.0f, 0.0f));
        g_ScratchDepths[lID.x][lID.y] = dm2;
    }

    memoryBarrierShared();
    barrier();

    // MIP 3
    if (all(equal(lID % uvec2(4), uvec2(0))))
    {
        float inTL = g_ScratchDepths[lID.x + 0][lID.y + 0];
        float inTR = g_ScratchDepths[lID.x + 2][lID.y + 0];
        float inBL = g_ScratchDepths[lID.x + 0][lID.y + 2];
        float inBR = g_ScratchDepths[lID.x + 2][lID.y + 2];

        float dm3 = XeGTAO_DepthMipFilter(inTL, inTR, inBL, inBR);
        imageStore(Images[Constants.OutDepthMip3Index], baseCoord / 4, vec4(dm3, 0.0f, 0.0f, 0.0f));
        g_ScratchDepths[lID.x][lID.y] = dm3;
    }

    memoryBarrierShared();
    barrier();

    // MIP 4
    if (all(equal(lID % uvec2(8), uvec2(0))))
    {
        float inTL = g_ScratchDepths[lID.x + 0][lID.y + 0];
        float inTR = g_ScratchDepths[lID.x + 4][lID.y + 0];
        float inBL = g_ScratchDepths[lID.x + 0][lID.y + 4];
        float inBR = g_ScratchDepths[lID.x + 4][lID.y + 4];

        float dm4 = XeGTAO_DepthMipFilter(inTL, inTR, inBL, inBR);
        imageStore(Images[Constants.OutDepthMip4Index], baseCoord / 8, vec4(dm4, 0.0f, 0.0f, 0.0f));
    }
}

// Weighted average depth filter
float XeGTAO_DepthMipFilter(float depth0, float depth1, float depth2, float depth3)
{
    float minDepth = min(min(depth0, depth1), min(depth2, depth3));

    const float effectRadius = GTAO_DEPTH_RANGE_SCALE_FACTOR * GTAO_DEFAULT_RADIUS * GTAO_DEFAULT_RADIUS_MULTIPLIER;
    const float falloffRange = GTAO_DEFAULT_FALLOFF_RANGE * effectRadius;

    const float falloffFrom = effectRadius * (1.0f - GTAO_DEFAULT_FALLOFF_RANGE);

    const float falloffMul = -1.0f / falloffRange;
    const float falloffAdd = falloffFrom / (falloffRange) + 1.0f;

    float weight0 = saturate((depth0 - minDepth) * falloffMul + falloffAdd);
    float weight1 = saturate((depth1 - minDepth) * falloffMul + falloffAdd);
    float weight2 = saturate((depth2 - minDepth) * falloffMul + falloffAdd);
    float weight3 = saturate((depth3 - minDepth) * falloffMul + falloffAdd);

    float weightSum = weight0 + weight1 + weight2 + weight3;

    return (weight0 * depth0 + weight1 * depth1 + weight2 * depth2 + weight3 * depth3) / weightSum;
}