/*
 * Copyright (c) 2023 - 2025 Rachit
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * GLSL Port of https://github.com/GameTechDev/XeGTAO/
 * Copyright (C) 2016-2021, Intel Corporation
 * SPDX-License-Identifier: MIT
 */

#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_buffer_reference2    : enable
#extension GL_EXT_scalar_block_layout  : enable

#include "Constants/AO/XeGTAO/Denoise.glsl"
#include "Math.glsl"
#include "Constants.glsl"
#include "MegaSet.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

vec4 XeGTAO_UnpackEdges(float packedVal);
void XeGTAO_AddSample(float ssaoValue, float edgeValue, inout float sum, inout float sumWeight);
void XeGTAO_Output(ivec2 pixelCoord, float outputValue);

void main()
{
    vec2  viewportPixelSize = 1.0f / vec2(textureSize(sampler2D(Textures[Constants.SourceEdgesIndex], Samplers[Constants.SamplerIndex]), 0));
    ivec2 pixelCoordBase    = ivec2(gl_GlobalInvocationID.xy) * ivec2(2, 1);

    float blurAmount = (Constants.FinalApply == 1) ? GTAO_DENOISE_BLUR_BETA : GTAO_DENOISE_BLUR_BETA / 5.0f;
    float diagWeight = 0.85f * 0.5f; // Rachit's Note: Magic constants, YAY

    // gather edge and visibility quads, used later
    vec2 gatherCenter = vec2(pixelCoordBase) * viewportPixelSize;
    vec4 edgesQ0      = textureGatherOffset(sampler2D(Textures[Constants.SourceEdgesIndex], Samplers[Constants.SamplerIndex]), gatherCenter, ivec2(0, 0));
    vec4 edgesQ1      = textureGatherOffset(sampler2D(Textures[Constants.SourceEdgesIndex], Samplers[Constants.SamplerIndex]), gatherCenter, ivec2(2, 0));
    vec4 edgesQ2      = textureGatherOffset(sampler2D(Textures[Constants.SourceEdgesIndex], Samplers[Constants.SamplerIndex]), gatherCenter, ivec2(1, 2));

    vec4 visQ0 = textureGatherOffset(sampler2D(Textures[Constants.SourceAOIndex], Samplers[Constants.SamplerIndex]), gatherCenter, ivec2(0, 0));
    vec4 visQ1 = textureGatherOffset(sampler2D(Textures[Constants.SourceAOIndex], Samplers[Constants.SamplerIndex]), gatherCenter, ivec2(2, 0));
    vec4 visQ2 = textureGatherOffset(sampler2D(Textures[Constants.SourceAOIndex], Samplers[Constants.SamplerIndex]), gatherCenter, ivec2(0, 2));
    vec4 visQ3 = textureGatherOffset(sampler2D(Textures[Constants.SourceAOIndex], Samplers[Constants.SamplerIndex]), gatherCenter, ivec2(2, 2));

    vec2 aoTerm;         // Pixel pixelCoordBase and Pixel pixelCoordBase + ivec2(1, 0)
    vec4 edgesC_LRTB[2];
    
    vec2 weightTL;
    vec2 weightTR;
    vec2 weightBL;
    vec2 weightBR;

    for (uint side = 0; side < 2; ++side)
    {
        ivec2 pixelCoord = ivec2(pixelCoordBase.x + side, pixelCoordBase.y);

        vec4 edgesL_LRTB = XeGTAO_UnpackEdges((side == 0) ? edgesQ0.x : edgesQ0.y);
        vec4 edgesT_LRTB = XeGTAO_UnpackEdges((side == 0) ? edgesQ0.z : edgesQ1.w);
        vec4 edgesR_LRTB = XeGTAO_UnpackEdges((side == 0) ? edgesQ1.x : edgesQ1.y);
        vec4 edgesB_LRTB = XeGTAO_UnpackEdges((side == 0) ? edgesQ2.w : edgesQ2.z);

        edgesC_LRTB[side] = XeGTAO_UnpackEdges((side == 0) ? edgesQ0.y : edgesQ1.x);

        // Edges aren't perfectly symmetrical: edge detection algorithm does not guarantee that a left edge on the right pixel will match the right edge on the left pixel (although
        // they will match in majority of cases). This line further enforces the symmetricity, creating a slightly sharper blur. Works real nice with TAA.
        edgesC_LRTB[side] *= vec4(edgesL_LRTB.y, edgesR_LRTB.x, edgesT_LRTB.w, edgesB_LRTB.z);

        // Allow some small amount of AO leaking from neighbours if there are 3 or 4 edges; this reduces both spatial and temporal aliasing
        // Rachit's Note: Moved to Constants.glsl

        float edginess    = (saturate(4.0f - GTAO_LEAK_THRESHOLD - dot(edgesC_LRTB[side], vec4(1.0f))) / (4.0f - GTAO_LEAK_THRESHOLD)) * GTAO_LEAK_STRENGTH;
        edgesC_LRTB[side] = saturate(edgesC_LRTB[side] + edginess);

        // for diagonals; used by first and second pass
        weightTL[side] = diagWeight * (edgesC_LRTB[side].x * edgesL_LRTB.z + edgesC_LRTB[side].z * edgesT_LRTB.x);
        weightTR[side] = diagWeight * (edgesC_LRTB[side].z * edgesT_LRTB.y + edgesC_LRTB[side].y * edgesR_LRTB.z);
        weightBL[side] = diagWeight * (edgesC_LRTB[side].w * edgesB_LRTB.x + edgesC_LRTB[side].x * edgesL_LRTB.w);
        weightBR[side] = diagWeight * (edgesC_LRTB[side].y * edgesR_LRTB.w + edgesC_LRTB[side].w * edgesB_LRTB.y);

        // first pass
        float ssaoValue   = (side == 0) ? visQ0[1] : visQ1[0];
        float ssaoValueL  = (side == 0) ? visQ0[0] : visQ0[1];
        float ssaoValueT  = (side == 0) ? visQ0[2] : visQ1[3];
        float ssaoValueR  = (side == 0) ? visQ1[0] : visQ1[1];
        float ssaoValueB  = (side == 0) ? visQ2[2] : visQ3[3];
        float ssaoValueTL = (side == 0) ? visQ0[3] : visQ0[2];
        float ssaoValueBR = (side == 0) ? visQ3[3] : visQ3[2];
        float ssaoValueTR = (side == 0) ? visQ1[3] : visQ1[2];
        float ssaoValueBL = (side == 0) ? visQ2[3] : visQ2[2];

        float sumWeight = blurAmount;
        float sum       = ssaoValue * sumWeight;

        XeGTAO_AddSample(ssaoValueL, edgesC_LRTB[side].x, sum, sumWeight);
        XeGTAO_AddSample(ssaoValueR, edgesC_LRTB[side].y, sum, sumWeight);
        XeGTAO_AddSample(ssaoValueT, edgesC_LRTB[side].z, sum, sumWeight);
        XeGTAO_AddSample(ssaoValueB, edgesC_LRTB[side].w, sum, sumWeight);

        XeGTAO_AddSample(ssaoValueTL, weightTL[side], sum, sumWeight);
        XeGTAO_AddSample(ssaoValueTR, weightTR[side], sum, sumWeight);
        XeGTAO_AddSample(ssaoValueBL, weightBL[side], sum, sumWeight);
        XeGTAO_AddSample(ssaoValueBR, weightBR[side], sum, sumWeight);

        aoTerm[side] = sum / sumWeight;

        XeGTAO_Output(pixelCoord, aoTerm[side]);
    }
}

vec4 XeGTAO_UnpackEdges(float packedVal)
{
    uint packedValUint = uint(packedVal * 255.5f);
    vec4 edgesLRTB;

    // there's really no need for mask (as it's an 8 bit input) but I'll leave it in so it doesn't cause any trouble in the future
    edgesLRTB.x = float((packedValUint >> 6) & 0x03) / 3.0f;
    edgesLRTB.y = float((packedValUint >> 4) & 0x03) / 3.0f;
    edgesLRTB.z = float((packedValUint >> 2) & 0x03) / 3.0f;
    edgesLRTB.w = float((packedValUint >> 0) & 0x03) / 3.0f;

    return saturate(edgesLRTB);
}

void XeGTAO_AddSample(float ssaoValue, float edgeValue, inout float sum, inout float sumWeight)
{
    float weight = edgeValue;

    sum       += (weight * ssaoValue);
    sumWeight += weight;
}

void XeGTAO_Output(ivec2 pixelCoord, float outputValue)
{
    outputValue *= (Constants.FinalApply == 1) ? GTAO_OCCLUSION_TERM_SCALE : 1.0f;

    imageStore(Images[Constants.OutAOIndex], pixelCoord, vec4(outputValue + (0.5f / 255.0f), 0.0f, 0.0f, 0.0f));
}